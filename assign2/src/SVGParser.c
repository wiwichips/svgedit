/******************************************************************************
 ******************************************************************************
 **	Author: 	Will Pringle following Dennis Nikitenko's API 				 **
 ** Student ID:	1056636														 **
 **																			 **
 ** Date: 		January 29 2020												 **
 **																			 **
 ** Citations:	(1)	libXmlExample.c written by Dodji Seketeli				 **
 **					used lines: 31, 33, 34, 45, 46, 48, 49, 50.				 **
 **				(2)	LinkedListAPI.h written by CIS*2750 S18					 **
 **					used lines:322, 326, 328, 329, 334, 337.				 **
 ******************************************************************************
 ******************************************************************************/

#include "SVGParser.h"
#include "helper.h"
#include <math.h>
#include <strings.h>

#define PI 3.14159265359

// A2 new functions
/** Function to create an SVG object based on the contents of an SVG file.
 * This function must validate the XML tree generated by libxml against a SVG schema file
 * before attempting to traverse the tree and create an SVGimage struct
 *@pre File name cannot be an empty string or NULL.
       File represented by this name must exist and must be readable.
       Schema file name is not NULL/empty, and represents a valid schema file
 *@post Either:
        A valid SVGimage has been created and its address was returned
		or 
		An error occurred, or SVG file was invalid, and NULL was returned
 *@return the pinter to the new struct or NULL
 *@param fileName - a string containing the name of the SVG file
**/
SVGimage* createValidSVGimage(char* fileName, char* schemaFile) {
	/// check if fileName or schemaFile are NULL, return NUll if either one is...
	if(!fileName || !schemaFile) {
		return NULL;
	}
	
	// call xmlReadFile
	xmlDoc* doc = xmlReadFile(fileName, NULL, 0);
	
	/// check if doc is NULl, return NULL if it is
	if(!doc) {
		return NULL;
	}
	
	// validate doc
	bool isValid = validateDoc(doc, schemaFile);
	printf("isValid = %d\n", isValid);
	
	/// check if its valid, return NULL if it is invalid
	if(!isValid) {
		return NULL;
	}
	
	// turn Doc into svgimage
	SVGimage* img = createSVGimageFromDoc(doc);
	
	return img;
}

/** Function to validating an existing a SVGimage object against a SVG schema file
 *@pre 
    SVGimage object exists and is not NULL
    schema file name is not NULL/empty, and represents a valid schema file
 *@post SVGimage has not been modified in any way
 *@return the boolean aud indicating whether the SVGimage is valid
 *@param obj - a pointer to a GPXSVGimagedoc struct
 *@param obj - the name of a schema file
 **/
bool validateSVGimage(SVGimage* image, char* schemaFile) {
	
	if(!image || !schemaFile) {
		return false;
	}
	
	// check if it follows the header file standards
//	validateHeaderConditions(image);
	
	// convert the SVGimage* to an XMLdoc*
	xmlDoc* doc = SVGimageToDoc(image);
	
	if(!doc) {
		puts("!doc");
		return false;
	}
	
	// check if its valid
	bool isValid = validateDoc(doc, schemaFile);
	
printf("isValid = %d\n", isValid);
	// free doc
	xmlFreeDoc(doc);
	
	return isValid;
}

bool validateHeaderConditions(SVGimage* image) {
	ListIterator itr;
	
	
	
	/// rectangle check
	List* rects = getRects(image);
	itr = createIterator(rects);
	for(Rectangle* data = nextElement(&itr); data != NULL; data = nextElement(&itr)) {
		// check basic conditions
		if(data->width < 0 || data->height < 0 || !(data->units) /*|| !(data->otherAttributes)*/) {
			freeListDataStructure(rects);
			return false;
		}
		
		if(validateAttributesAgainstHeaderConditions(data->otherAttributes)) {
			freeListDataStructure(rects);
			return false;
		}
		
	}
	freeListDataStructure(rects); // frees the list
	
	/// circle check
	List* circles = getCircles(image);
	itr = createIterator(circles);
	for(Circle* data = nextElement(&itr); data != NULL; data = nextElement(&itr)) {
		// check basic conditions
		if(data->r < 0 || !(data->units) || !(data->otherAttributes)) {
			freeListDataStructure(circles);
			return false;
		}
		
		// check the otherattributes list
		if(validateAttributesAgainstHeaderConditions(data->otherAttributes)) {
			freeListDataStructure(circles);
			return false;
		}
	}
	freeListDataStructure(circles);
	
	/// path check
	List* paths = getCircles(image);
	itr = createIterator(paths);
	for(Path* data = nextElement(&itr); data != NULL; data = nextElement(&itr)) {
		// check basic conditions
		if(!(data->data) /*|| !(data->otherAttributes)*/) { // TODO
			freeListDataStructure(paths);
			return false;
		}
		
		// check the otherattributes list
		if(validateAttributesAgainstHeaderConditions(data->otherAttributes)) {
			freeListDataStructure(paths);
			return false;
		}
	}
	freeListDataStructure(paths);
	
	/// group check
	List* groups = getGroups(image);
	itr = createIterator(groups);
	for(Group* data = nextElement(&itr); data != NULL; data = nextElement(&itr)) {
		// check basic conditions
/*		if(!(data->data) || !(data->otherAttributes)) { // TODO
			freeListDataStructure(paths);
			return false;
		}
*/
		// check the otherattributes list
		if(validateAttributesAgainstHeaderConditions(data->otherAttributes)) {
			freeListDataStructure(paths);
			return false;
		}
	}
	freeListDataStructure(paths);
	
	return true;
}

bool validateAttributesAgainstHeaderConditions(List* attributes) {
	
	ListIterator itr = createIterator(attributes);
	for(Attribute* data = nextElement(&itr); data != NULL; data = nextElement(&itr)) {
		if(!(data->name) || !(data->value)) {
			return false;
		}
	}
	
	return true;
}

bool writeSVGimage(SVGimage* image, char* fileName) {
	// check if either one is NULL
	if(!image || !fileName) {
		return false;
	}
	
	// convert it to a doc
	xmlDoc* doc = NULL;
	doc = SVGimageToDoc(image);
	
	// check if the doc is NULL
	if(!doc) {
		puts("test");
		return false;
	}
	
	// write the doc to file
	int result = -1;
	result = xmlSaveFormatFileEnc(fileName, doc, "UTF-8", 1);
	
	
	xmlFreeDoc(doc);
	xmlCleanupParser();
	
	//
	if(result > 0) {
		return true;
	}
	
	return false;
}

void setAttribute(SVGimage* image, elementType elemType, int elemIndex, Attribute* newAttribute) {
	
	return;
}

void addComponent(SVGimage* image, elementType type, void* newElement) {
	
	return;
}

char* attrToJSON(const Attribute *a) {
	return NULL;
}

char* circleToJSON(const Circle *c) {
	return NULL;
}

char* rectToJSON(const Rectangle *r) {
	return NULL;
}

char* pathToJSON(const Path *p) {
	return NULL;
}

char* groupToJSON(const Group *g) {
	return NULL;
}

char* attrListToJSON(const List *list) {
	return NULL;
}

char* circListToJSON(const List *list) {
	return NULL;
}

char* rectListToJSON(const List *list) {
	return NULL;
}

char* pathListToJSON(const List *list) {
	return NULL;
}

char* groupListToJSON(const List *list) {
	return NULL;
}

char* SVGtoJSON(const SVGimage* imge) {
	return NULL;
}

/// Will Pringle's Helper Functions A2

// creating a doc from an svgimage functions
xmlDoc* SVGimageToDoc(SVGimage* image) {
	if(!image) {
		return NULL;
	}
	
	xmlDoc* doc = NULL;
	xmlNode* root_node = NULL; 
	xmlNs* ns = NULL;
	
	// Creates a new document, a node and set it as a root node
	doc = xmlNewDoc(BAD_CAST "1.0"); 
    root_node = xmlNewNode(NULL, BAD_CAST "svg"); // make the svg thing
    xmlDocSetRootElement(doc, root_node);
		
	// set up namespace
	ns = xmlNewNs(root_node, BAD_CAST image->namespace, NULL);
	xmlSetNs(root_node, ns);

	// populate title and description if there is one
	if(image->title[0] != '\0'){
		xmlNewChild(root_node, NULL, BAD_CAST "title", BAD_CAST image->title);
	}
	else {
		puts("image->title[0] == '\0'");
	}
	
	if(image->description[0] != '\0') {
		xmlNewChild(root_node, NULL, BAD_CAST "desc", BAD_CAST image->description);
	}
	
	// add attributes to svg image base node
	addAttributeNodesToTree(root_node, image->otherAttributes);
	
	// add rects, circles, and paths from the node to the root_node
	addAllElementsToDoc(image->rectangles, image->circles, image->paths, root_node);
	
	// add all groups 
	addGroupsToDoc(image->groups, root_node);
	
	return doc;
}

void addGroupToDoc(Group* g, xmlNode* parentNode) {
	// make groupNode a child of parentNode
	xmlNode* groupNode = xmlNewChild(parentNode, NULL, BAD_CAST "g", NULL);
	
	// add misc other attributes to the g
	addAttributeNodesToTree(groupNode, g->otherAttributes);
	
	// add all elements
	addAllElementsToDoc(g->rectangles, g->circles, g->paths, groupNode);
	
	// make recursive call to get groups in groups
	addGroupsToDoc(g->groups, groupNode);
}

void addRectangleToDoc(Rectangle* rect, xmlNode* parentNode) {
	xmlNode* temp = NULL;
	char* floatString = NULL;
	
	// make a rectangle child of the current node
	temp = xmlNewChild(parentNode, NULL, BAD_CAST "rect", NULL);
	
	// add the x value
	floatString = floatToString(rect->x);
	floatString = addUnitsToString(floatString, rect->units);
	xmlNewProp(temp, BAD_CAST "x", BAD_CAST floatString);
	free(floatString);
	
	// add the y value
	floatString = floatToString(rect->y);
	floatString = addUnitsToString(floatString, rect->units);
	xmlNewProp(temp, BAD_CAST "y", BAD_CAST floatString);
	free(floatString);
	
	// add the width value
	floatString = floatToString(rect->width);
	floatString = addUnitsToString(floatString, rect->units);
	xmlNewProp(temp, BAD_CAST "width", BAD_CAST floatString);
	free(floatString);
	
	// add the height
	floatString = floatToString(rect->height);
	floatString = addUnitsToString(floatString, rect->units);
	xmlNewProp(temp, BAD_CAST "height", BAD_CAST floatString); // WHY THE &??????!!!
	free(floatString);
	
	// add other attributes
	addAttributeNodesToTree(temp, rect->otherAttributes);
}

void addCircleToDoc(Circle* circle, xmlNode* parentNode) {
	xmlNode* temp = NULL;
	char* floatString = NULL;
	
	// make a circle child of the current node
	temp = xmlNewChild(parentNode, NULL, BAD_CAST "circle", NULL);
	
	// set the cx
	floatString = floatToString(circle->cx);
	floatString = addUnitsToString(floatString, circle->units);
	xmlNewProp(temp, BAD_CAST "cx", BAD_CAST floatString); // WHY THE &??????!!!
	free(floatString);
	
	// set the cy
	floatString = floatToString(circle->cy);
	floatString = addUnitsToString(floatString, circle->units);
	xmlNewProp(temp, BAD_CAST "cy", BAD_CAST floatString); // WHY THE &??????!!!
	free(floatString);
	
	// set the r
	floatString = floatToString(circle->r);
	floatString = addUnitsToString(floatString, circle->units);
	xmlNewProp(temp, BAD_CAST "r", BAD_CAST floatString); // WHY THE &??????!!!
	free(floatString);
	
	// add other attributes
	addAttributeNodesToTree(temp, circle->otherAttributes);
}

void addPathToDoc(Path* path, xmlNode* parentNode) {
	xmlNode* temp = NULL;
	
	// make a path child of the current node
	temp = xmlNewChild(parentNode, NULL, BAD_CAST "path", NULL);
	xmlNewProp(temp, BAD_CAST "d", BAD_CAST path->data);
	
	// add other attributes
	addAttributeNodesToTree(temp, path->otherAttributes);
}

void addAllElementsToDoc(List* rects, List* circles, List* paths, xmlNode* node) {
	ListIterator itr;
	
	/// rectangles 
	itr = createIterator(rects);
	for(Rectangle* data = nextElement(&itr); data != NULL; data = nextElement(&itr)) {
		addRectangleToDoc(data, node);
	}
	
	/// circles 
	itr = createIterator(circles);
	for(Circle* data = nextElement(&itr); data != NULL; data = nextElement(&itr)) {
		addCircleToDoc(data, node);
	}
	
	/// paths
	itr = createIterator(paths);
	for(Path* data = nextElement(&itr); data != NULL; data = nextElement(&itr)) {
		addPathToDoc(data, node);
	}
	
}

void addGroupsToDoc(List* groups, xmlNode* node) {
	ListIterator itr;
	
	/// loop through groups and add them
	itr = createIterator(groups);
	for(Group* data = nextElement(&itr); data != NULL; data = nextElement(&itr)) {
		addGroupToDoc(data, node);
		
		// add all the elements within the group
	}
	
}

int addAttributeNodesToTree(xmlNode* node, List* otherAttributes) {
	
	ListIterator itr = createIterator(otherAttributes);
	
	for(Attribute* attData = nextElement(&itr); attData != NULL;) {
		// add the new attribute
		xmlNewProp(node, BAD_CAST attData->name, BAD_CAST attData->value);
		
		// advance the LL to the next attribute
		attData = nextElement(&itr);
	}

	return 0;
}


// validate doc
bool validateDoc(xmlDoc* doc, char* schemaFile) {
	xmlSchemaParserCtxtPtr context = NULL;
	xmlSchemaPtr schema = NULL;
	xmlSchemaValidCtxtPtr validContext = NULL;
	int isValid = 0;
	
	// use the file to get the cotext
	context = xmlSchemaNewParserCtxt((const char*)schemaFile);

	// create schema using context
	schema = xmlSchemaParse(context);
	
	// create validcontext using schema
	validContext = xmlSchemaNewValidCtxt(schema);
	
	if(!validContext) {
		xmlSchemaFree(schema);
		xmlSchemaFreeParserCtxt(context);
		puts("validContext is bad");
//		xmlSchemaFreeValidCtxt(validContext);
		return false;
	}
	
	// check if it is valid
	isValid = xmlSchemaValidateDoc(validContext, doc);

	printf("isValid = %d\n", !isValid);
	
	// frees
	xmlSchemaFree(schema);
	xmlSchemaFreeParserCtxt(context);
	xmlSchemaFreeValidCtxt(validContext);
	
	puts("validateDoc");
	return !isValid;
	
}

// create valid SVGimage from Doc
SVGimage* createSVGimageFromDoc(xmlDoc* doc) {
	
	// Get the root element node
    xmlNode* root_element = xmlDocGetRootElement(doc);

	// CREATE SPACE FOR SVGIMAGE
	SVGimage* image = malloc(sizeof(SVGimage));
	
	// tempoarily setting list variables to NULL
	image->rectangles = initializeList(&rectangleToString, &deleteRectangle, &comparePaths);
	image->circles = initializeList(&rectangleToString, &deleteCircle, &comparePaths);
	image->paths = initializeList(&rectangleToString, &deletePath, &comparePaths);
	image->groups = initializeList(&groupToString, &deleteGroup, &comparePaths);
	image->otherAttributes = initializeList(&rectangleToString, &deleteAttribute, &comparePaths);
	
	// add other attributes to the thing
	strcpy(image->namespace, (char*) root_element->ns->href);
	
	// populate attributes
	xmlAttr *attr = NULL;
	bool titleFlag = false;
	bool descFlag = false;
	bool nsFlag = false; // there must be a namespace, so this must be true
	
	// est the title and desc to empty
	strcpy(image->title, "");
	strcpy(image->description, "");
	
	// 
	for (attr = root_element->properties; attr != NULL; attr = attr->next) {
		xmlNode *value = attr->children;
		char *attrName = (char *)attr->name;
		char *cont = (char *)(value->content);
		
		// if it is not xmlns
		if(!strcmpu(attr->name, "title")) {
			strcpy(image->title, (char*) attr->children->content);
			titleFlag = true;
puts("!strcmpu(attr->name, \"title\"");
			
		} else if(!strcmpu(attr->name, "desc")) {
			strcpy(image->description, (char*) attr->children->content);
			descFlag = true;
puts("!strcmpu(attr->name, \"desc\"");
		} else {
			insertBack(image->otherAttributes, addAttribute(attrName, cont));
			nsFlag = true;
			printf("this should never be called --> attrName = %s\tcont = %s", attrName, cont);
			
		}
	}

	// check if there is not a desc or title
	if(!titleFlag) {
		strcpy(image->title, "");
		puts("!titleFlag");
	}
	
	if(!descFlag) {
		strcpy(image->description, "");
		puts("!descFlag");
	}

	// if there is no ns it is not valid
	if(!nsFlag) {
		deleteSVGimage(image);
		return NULL;
	}
	
	// populating the svgimage
	bog(image, root_element->children);

	// frees
    xmlFreeDoc(doc); // free document
    xmlCleanupParser(); // free global variable 
	
	return image;
}

// misc functions
void freeListDataStructure(List* list) {
	
	if(!list) {
		return;
	}
	
	Node* tmp = list->head;
	Node* freeMe = NULL;
	
	while(tmp) {
		freeMe = tmp;
		tmp = tmp->next;
		free(freeMe);
		freeMe = NULL;
	}
	
	free(list);
	return;
}
/*
List* copyList(List* list) {
	List* copiedList;
}
*/

char* floatToString(float num) {
	int floatLength = 0;
	char* floatString = NULL;
	
	floatLength = snprintf(NULL, 0, "%f", num);
	floatString = malloc(sizeof(char) * (floatLength + 1));
	snprintf(floatString, floatLength + 1, "%f", num);
	
	return floatString;
}

char* addUnitsToString(char* string, char units[50]) {
	int stringLength = strlen(string) + strlen(units) + 1;
	
	// realloc for the string length
	string = realloc(string, sizeof(char) * stringLength);
	
	// concatenate the strings
	strcat(string, (const char*) units);	
	
	return string;
}


/// Will Pringle's Helper functions A1
List* combineList(List* source, List* destination) {
	
	// iterate through each element in source and add it to destination
	ListIterator itr = createIterator(source);
	
	void* data = nextElement(&itr);
	while (data != NULL)
	{
		
		//destination
		insertBack(destination, data);
		
		// advance to the next data
		data = nextElement(&itr);
	}

	return source;
}

List* getAllRectsFromGroups(Group* g, List* list) {
    
	// add the list of rectangles to the lists
	combineList(g->groups, list);

    // if there is at least one group in the group list
    if(getLength(g->groups)) {
        
        // iterate through each group and call goThroughGroup recursively
        ListIterator itr = createIterator(g->groups);
        
        Group* data = nextElement(&itr);
		
		// iterate through each thing 
        while (data != NULL) {
            getAllRectsFromGroups(data, list);
            data = nextElement(&itr);
            
        }
    }
    
    return list;
}

List* getAllCirclesFromGroups(Group* g, List* list) {
    
	// add the list of rectangles to the lists

	combineList(g->circles, list);


    // if there is at least one group in the group list
    if(getLength(g->groups)) {
        
        // iterate through each group and call goThroughGroup recursively
        ListIterator itr = createIterator(g->groups);
        
        Group* data = nextElement(&itr);
		
//		puts("circle called and added");
		
		// iterate through each thing 
        while (data != NULL) {
            getAllCirclesFromGroups(data, list);
            data = nextElement(&itr);
            
        }
    }
    
    return list;
}

List* getAllGroupsFromGroups(Group* g, List* list) {
    
	// add the list of rectangles to the lists

	combineList(g->circles, list);


    // if there is at least one group in the group list
    if(getLength(g->groups)) {
        
        // iterate through each group and call goThroughGroup recursively
        ListIterator itr = createIterator(g->groups);
        
        Group* data = nextElement(&itr);
		
//		puts("circle called and added");
		
		// iterate through each thing 
        while (data != NULL) {
            getAllGroupsFromGroups(data, list);
            data = nextElement(&itr);
            
        }
    }
    
    return list;
}

List* getAllPathsFromGroups(Group* g, List* list) {
    
	// add the list of rectangles to the lists
	combineList(g->paths, list);

    // if there is at least one group in the group list
    if(getLength(g->groups)) {
        
        // iterate through each group and call goThroughGroup recursively
        ListIterator itr = createIterator(g->groups);
        
        Group* data = nextElement(&itr);
		
		// iterate through each thing 
        while (data != NULL) {
            getAllPathsFromGroups(data, list);
            data = nextElement(&itr);
            
        }
    }
    
    return list;
}

int attributeListCounter(List* list, int test) {
	
	int num = 0;
	ListIterator itr = createIterator(list);
	
	
	if(test == 1) {
		// rectangle
		Rectangle* data = NULL;
		
		data = nextElement(&itr);
		while (data != NULL)
		{
			// 
			num += getLength(data->otherAttributes);
			

			data = nextElement(&itr);
		}
		
	} else if (test == 2) {
		// circle
		Circle* data = NULL;
		
		data = nextElement(&itr);
		while (data != NULL)
		{
			// 
			num += getLength(data->otherAttributes);

			data = nextElement(&itr);
		}
		
	} else if (test == 3) {
		// path
		Path* data = NULL;
		
//		puts("hello world");
		
		data = nextElement(&itr);
		while (data != NULL)
		{
			// 
			
			num += getLength(data->otherAttributes);

			data = nextElement(&itr);
		}
		
	} else if (test == 4) {
		// group
		Group* data = NULL;
		
		data = nextElement(&itr);
		while (data != NULL)
		{
			// 
			num += getLength(data->otherAttributes);

			data = nextElement(&itr);
		}
		
	} else {
//		puts("something went wrong");
	}

	
	return num;
	
}

int goThroughGroupAndAddAttributes(Group* g) {
	
	// if the group is null, return
	if(!g) {
//puts("null group");
		return -1;
	}
	
	// do stuff
	int attributes = 0;
	
	attributes += attributeListCounter(g->rectangles, 1);
	attributes += attributeListCounter(g->circles, 2);
	attributes += attributeListCounter(g->paths, 3);
	attributes += getLength(g->otherAttributes);
	
	
	// if there is at least one group in the group list
	if(getLength(g->groups)) {
		
		// iterate through each group and call goThroughGroupAndAddAttributes recursively
		ListIterator itr = createIterator(g->groups);
		
		Group* data = nextElement(&itr);
		while (data != NULL)
		{
			// 
			attributes += goThroughGroupAndAddAttributes(data);
			
			data = nextElement(&itr);
			
		}
		
	}
	
	return attributes;
	
}

// will return a list of elements that match a criteria
int findElements(List * list, const void* searchRecord,
int (*compareFunction)(const void* first, const void* second)
){
	int matches = 0;
	
//	List* matchList = initializeList(printFunction, deleteFunction, compareFunction);
	
	if (compareFunction == NULL)
		return -1;

	ListIterator itr = createIterator(list);

	void* data = nextElement(&itr);
	while (data != NULL)
	{
		if (compareFunction(data, searchRecord)) {
			matches++;
		}

		data = nextElement(&itr);
	}

	return matches;
}


// 
int getGroupLength(Group* group) {
	
	if(!group) {
		return 0;
	}
	
	printf("group = %p\n", group);
	
	puts("");
	
	printf("group->rectangles = %p\n", group->rectangles);
	printf("group->circles = %p\n", group->circles);
	printf("group->paths = %p\n", group->paths);
	printf("group->groups = %p\n", group->groups);
	
	int size = 0;
    size += getLength(group->rectangles);
	size += getLength(group->circles);
	size += getLength(group->paths);
	size += getLength(group->groups);
	
	return size;
}

// first parameter is for the element to compare, second is length
int compareGroupLength(const void* first, const void* second) {
	Group* group = (Group*) first;
	int* len = (int*) second;
	
//	printf("\t\tdata = {%d}\t sRecord = {%d}\n", getGroupLength(group), *len);
	
	puts("right before getGroupLength(group) == *len");
	if(getGroupLength(group) == *len) {
		return 1;
	}
	
	return 0;
}


// compares an unsigned string to a string, s1 is unsigned, s2 is signed
int strcmpu(const unsigned char* s1, const char* s2) {
	return strcmp((const char*) s1, s2);
}

// returns an integer from a string and sets the second string to string portion
int stringToInt(char* string, char* end) {
	return (int) strtol(string, &end, 10);
}

// 
Attribute* addAttribute(char* attrName, char* cont) {
	Attribute* a;
	
	// alloacte space for the attribute and the strings
	a = malloc(sizeof(Attribute));
	a->name = malloc(sizeof(char) * (strlen(attrName) +1));
	a->value = malloc(sizeof(char) * (strlen(cont) +1));
	
	// copy the information to the strings
	strcpy(a->name, attrName);
	strcpy(a->value, cont);
	return a;
}

List* addToList(List* head, void* data, char* (*printFunction)(void* toBePrinted),void (*deleteFunction)(void* toBeDeleted)) {
	
	// if there are no elements in the linked list, add a starting node
	if (head == NULL) {
		head = initializeList(printFunction, deleteFunction, &comparePaths);
		insertBack(head, data);
		
	} else { // if there is already a node in the linked list, add another one
		insertBack(head, data);
		
	}
	
	return head;
}

// shape paresers
Rectangle* parseRect(xmlNode* cur_node) {
	xmlAttr* attr;
	Rectangle* rect;
	float x = 0;
	float y = 0;
	float width = 0;
	float height = 0;
	char* end;

	
	// allocate space for a rectanle and create list of other Attributes
	rect = malloc(sizeof(Rectangle));
	rect->otherAttributes = initializeList(&attributeToString, &deleteAttribute, &comparePaths);
	
	// ensure a null character
	rect->units[0] = '\0';
	
	// go through each attribute
	for (attr = cur_node->properties; attr != NULL; attr = attr->next)
	{
		xmlNode *value = attr->children;
		char *attrName = (char *)attr->name;
		char *cont = (char *)(value->content);
		
		// check if its valid
		if(!attrName || !(value->content)) {
			puts("BAD1 - invalid attrName == NULL");
			free(rect);
			return NULL;
		}
		
		
		if(!strcmp(attrName, "x")) {
			x = strtof(cont, NULL);
			rect->x = x;
			
		} else if(!strcmp(attrName, "y")) {
			y = strtof(cont, NULL);
			rect->y = y;
			
		} else if(!strcmp(attrName, "width")) {
			width = strtof(cont, &end);
			rect->width = width;
			
		} else if(!strcmp(attrName, "height")) {
			height = strtof(cont, NULL);	
			rect->height = height;
			
		// all othre attributes go here
		} else {
			
			// add the attribute to the list
			insertBack(rect->otherAttributes, addAttribute(attrName, cont));
		}
		
	}
	
	// copy the units from the x to the units in the struct
	strcpy(rect->units, end);

	return rect;
}

Circle* parseCircle(xmlNode* cur_node) {
	xmlAttr* attr = NULL;
	Circle* circle = NULL;
	float cx = 0;
	float cy = 0;
	float r = 0;
	char* end; // used to get units

	
	// allocate space for a rectanle and create list of other Attributes
	circle = malloc(sizeof(Rectangle));
	circle->otherAttributes = initializeList(&attributeToString, &deleteAttribute, &comparePaths);
	
	// ensure a null character
	circle->units[0] = '\0';
	
	// go through each attribute
	for (attr = cur_node->properties; attr != NULL; attr = attr->next)
	{
		xmlNode *value = attr->children;
		char *attrName = (char *)attr->name;
		char *cont = (char *)(value->content);
		
		// check if its valid
		if(!attrName || !(value->content)) {
			puts("BAD1 - invalid attrName == NULL");
			free(circle);
			return NULL;
		}
		
		if(!strcmp(attrName, "cx")) {
			cx = strtof(cont, NULL);
			circle->cx = cx;
			
		} else if(!strcmp(attrName, "cy")) {
			cy = strtof(cont, NULL);
			circle->cy = cy;
			
		} else if(!strcmp(attrName, "r")) {
			r = strtof(cont, &end);
			
			// check if r < 0
			if(r < 0) {
				puts("BAD2 - invalid r < 0");
				
				free(circle);
				return NULL;
			}
			
			circle->r = r;
			
			
		// all othre attributes go here
		} else {
			
			// add the attribute to the list
			insertBack(circle->otherAttributes, addAttribute(attrName, cont));
			
		}
		
	}
		
	// copy the units from the x to the units in the struct
	strcpy(circle->units, end);

	return circle;
}

Path* parsePath(xmlNode* cur_node) {
	xmlAttr* attr = NULL;
	Path* path = NULL;
	
	// allocate space for a rectanle and create list of other Attributes
	path = malloc(sizeof(Path));
	path->otherAttributes = initializeList(&attributeToString, &deleteAttribute, &comparePaths);
	
	// allocate space for the path data and set the first index to /0
	path->data = malloc(sizeof(char) * 2);
	path->data[0] = '\0';
	
	// go through each attribute
	for (attr = cur_node->properties; attr != NULL; attr = attr->next) {
		xmlNode *value = attr->children;
		char *attrName = (char *)attr->name;
		char *cont = (char *)(value->content);
		
		
		// check if its valid
		if(!attrName || !(value->content)) {
			puts("BAD1 - invalid attrName == NULL");
			free(path);
			return NULL;
		}
		
		if(!strcmp(attrName, "d")) {
//			printf("content is = {%s}\n}", cont);
			
			// realloc size for the path
			path->data = realloc(path->data, sizeof(char) * (strlen(cont)+1));
			
			// copy the string over
			sprintf(path->data, "%s", cont);
			
		// all othre attributes go here
		} else {
			
			// add the attribute to the list
			insertBack(path->otherAttributes, addAttribute(attrName, cont));
			
		}	
	}

	return path;
}

Group* parseGroup(xmlNode* groupNode) {
	Group* g = NULL;
	
	// allocate space for the group
	g = malloc(sizeof(Group));
	
	xmlNode *cur_node = NULL;
	
	g->rectangles = initializeList(&rectangleToString, &deleteRectangle, &comparePaths);
	g->circles = initializeList(&rectangleToString, &deleteCircle, &comparePaths);
	g->paths = initializeList(&rectangleToString, &deletePath, &comparePaths);
	g->groups = initializeList(&groupToString, &deleteGroup, &comparePaths);
	g->otherAttributes = initializeList(&rectangleToString, &deleteAttribute, &comparePaths);
	
	
	// get attributes
	// populate attributes
	xmlAttr *attr;
	for (attr = groupNode->parent->properties; attr != NULL; attr = attr->next)
	{		
		xmlNode *value = attr->children;
		char *attrName = (char *)attr->name;
		char *cont = (char *)(value->content);
		
		// check if its valid
		if(!attrName || !(value->content)) {
			puts("BAD1 - invalid attrName == NULL");
			free(g);
			return NULL;
		}
		
		// if it is not xmlns
		if(strcasecmp(attrName, "xmlns")) {
			insertBack(g->otherAttributes, addAttribute(attrName, cont));
		}
	}

	// get all the circles, groups, rectangles, etc
	// while the current node isn't null, set it to the next node
    for (cur_node = groupNode; cur_node != NULL; cur_node = cur_node->next) {
        if (cur_node->type == XML_ELEMENT_NODE) {
			// place in rectangles, circles, paths, groups
			if(!strcmpu(cur_node->name, "rect")) {
				insertBack(g->rectangles, parseRect(cur_node));

			} else if(!strcmpu(cur_node->name, "circle")) {
				insertBack(g->circles, parseCircle(cur_node));
				
			} else if(!strcmpu(cur_node->name, "path")) {
				insertBack(g->paths, parsePath(cur_node));
				
			}
			
			// groups
			else if(!strcmpu(cur_node->name, "g")) {
				insertBack(g->groups, parseGroup(cur_node->children));
			}
        }
    }
	
	return g;
	
}

void bog(SVGimage* image, xmlNode *root) {
	
	xmlNode *cur_node = NULL;

	// while the current node isn't null, set it to the next node
    for (cur_node = root; cur_node != NULL; cur_node = cur_node->next) {
        if (cur_node->type == XML_ELEMENT_NODE) {
			
			// place in title, description
			if(!strcmpu(cur_node->name, "title")) {
				strcpy(image->title, (char*) cur_node->children->content);
				
			} else if(!strcmpu(cur_node->name, "desc")) {
				strcpy(image->description, (char*) cur_node->children->content);
				
			}
			
			// place in rectangles, circles, paths, groups
			/*else*/ if(!strcmpu(cur_node->name, "rect")) {
				insertBack(image->rectangles, parseRect(cur_node));
				
				
			} else if(!strcmpu(cur_node->name, "circle")) {
				insertBack(image->circles, parseCircle(cur_node));
				
			} else if(!strcmpu(cur_node->name, "path")) {
				insertBack(image->paths, parsePath(cur_node));
				
			}
			
			// groups
			else if(!strcmpu(cur_node->name, "g")) {
				insertBack(image->groups, parseGroup(cur_node->children));
			}
        }
    }
}


/* Public API - main */

/** Function to create an SVG object based on the contents of an SVG file.
 *@pre File name cannot be an empty string or NULL.
       File represented by this name must exist and must be readable.
 *@post Either:
        A valid SVGimage has been created and its address was returned
		or 
		An error occurred, and NULL was returned
 *@return the pinter to the new struct or NULL
 *@param fileName - a string containing the name of the SVG file
**/
SVGimage* createSVGimage(char* fileName) {
	
	// check for NULL
	if(!(fileName)) {
		return NULL;
	}
	
	xmlDoc *doc = NULL;
	SVGimage *image = NULL;

	// intialize library / check for other issues
    LIBXML_TEST_VERSION

    // parse the file and get the DOM
    doc = xmlReadFile(fileName, NULL, 0);
	
	// if xml had problems
	if(doc == NULL) {
		// cleanup the aprser
		xmlCleanupParser();
		return NULL;
	}
	
	image = createSVGimageFromDoc(doc);
	
	if(!image) {
		return NULL;
	}

	/*
	 * return the svgimage
	 */
	return image;
}

/** Function to create a string representation of an SVG object.
 *@pre SVGimgage exists, is not null, and is valid
 *@post SVGimgage has not been modified in any way, and a string representing the SVG contents has been created
 *@return a string contaning a humanly readable representation of an SVG object
 *@param obj - a pointer to an SVG struct
**/
char* SVGimageToString(SVGimage* img) {
	char* temp = malloc(sizeof(char) * 2);
	temp[0] = 's';
	temp[1] = '\0';
	return temp;
}
/////TODO TODO
/** Function to delete image content and free all the memory.
 *@pre SVGimgage  exists, is not null, and has not been freed
 *@post SVSVGimage  had been freed
 *@return none
 *@param obj - a pointer to an SVG struct
**/
void deleteSVGimage(SVGimage* img) {
	// check for NULL
	if(img == NULL) {
		return;
	}
	
	// free all the lists
	freeList(img->rectangles);
	freeList(img->circles);
	freeList(img->paths);
	freeList(img->groups);
	freeList(img->otherAttributes);
	
	// frees the space that held the struct
	free(img);
}


// Function that returns a list of all rectangles in the image.  
List* getRects(SVGimage* img) {
	// check for NULL
	if(!(img)) {
		return NULL;
	}
	
	List* list = initializeList(&rectangleToString, &deleteRectangle, &comparePaths);
	
	combineList(img->rectangles, list);
	
	// if there is at least one group in the group list
    if(getLength(img->groups)) {
        
        // iterate through each group and call goThroughGroup recursively
        ListIterator itr = createIterator(img->groups);
        
        Group* data = nextElement(&itr);
        while (data != NULL)
        {
            // 
            getAllRectsFromGroups(data, list);
			
            data = nextElement(&itr);
        }
    }
	
	return list; // fix this
}

// Function that returns a list of all circles in the image.  
List* getCircles(SVGimage* img) {
	// check for NULL
	if(!(img)) {
		return NULL;
	}
	
	List* list = initializeList(&circleToString, &deleteCircle, &comparePaths);
	
	combineList(img->circles, list);
	
	// if there is at least one group in the group list
    if(getLength(img->groups)) {
        
        // iterate through each group and call goThroughGroup recursively
        ListIterator itr = createIterator(img->groups);
        
        Group* data = nextElement(&itr);
        while (data != NULL)
        {
            // 
            getAllCirclesFromGroups(data, list);
			
            data = nextElement(&itr);
        }
    }
	
	return list; // fix this
}

// Function that returns a list of all groups in the image.  
List* getGroups(SVGimage* img) {
	// check for NULL
	if(!(img)) {
		return NULL;
	}
	
	
	
	return img->groups; // fix this
}

// Function that returns a list of all paths in the image.  
List* getPaths(SVGimage* img) {
	// check for NULL
	if(!(img)) {
		return NULL;
	}
	
	List* list = initializeList(&pathToString, &deletePath, &comparePaths);
	
	combineList(img->paths, list);
	
	// if there is at least one group in the group list
    if(getLength(img->groups)) {
        
        // iterate through each group and call goThroughGroup recursively
        ListIterator itr = createIterator(img->groups);
        
        Group* data = nextElement(&itr);
        while (data != NULL)
        {
            // 
            getAllPathsFromGroups(data, list);
			
            data = nextElement(&itr);
        }
    }
	
	return list; // fix this
}

// Function that returns the number of all rectangles with the specified area
int numRectsWithArea(SVGimage* img, float area) {
	// check for NULL
	if(!(img) || area < 0) {
		return 0;
	}
	
	// allocate the base
	Rectangle* base = malloc(sizeof(Rectangle));
	base->width = area;
	base->height = 1;
	
	// get a list of the rectangles
	List* list = getRects(img);
	
	// find the elements and put them in a list
	int matches = findElements(list, base, &compareRectangles);
	
	// free 
	free(base);
	freeListDataStructure(list);
	
	return matches;
}

// Function that returns the number of all circles with the specified area
int numCirclesWithArea(SVGimage* img, float area) {
	// check for NULL
	if(!(img) || area < 0) {
		return 0;
	}
	
	//allocate the base
	Circle* base = malloc(sizeof(Circle));
	
	// set the radius to the radius (since comparing area using radius)
	base->r = sqrt(area / PI);
	
	// get a list of the rectangles
	List* list = getCircles(img);
	
	// find the elements and put them in a list
	int matches = findElements(list, base, &compareCircles);
	
	// free 
	free(base);
	freeListDataStructure(list);
	
	return matches;
}

// Function that returns the number of all paths with the specified data - i.e. Path.data field
int numPathsWithdata(SVGimage* img, char* data) {
	// check for NULL
	if(!(img)) {
		return 0;
	}
	
	// allocate the base
	Path* base = malloc(sizeof(Path));
	
	// set the string to point to the same data as the data string
	base->data = data;
	
	List* list = getPaths(img);
	
	// find the elements and put them in a list
	int matches = findElements(list, base, &comparePaths);
	
	free(base);
	freeListDataStructure(list);
	
	return matches;
}

// Function that returns the number of all groups with the specified length - see A1 Module 2 for details
int numGroupsWithLen(SVGimage* img, int len) {
	int matches = 0;
	// check for NULL
	if(!(img) || len < 0) {
		return 0;
	}
	
	List* list = getGroups(img);
	
	printf("list->length = %d\n", getLength(list));
	
	matches = findElements(list, &len, &compareGroupLength);
	
//	freeListDataStructure(list);
	
	return matches;
}


// Sums all the attributes
int numAttr(SVGimage* img) {
	//check for NULL
	if (!img) {
		return 0;
	}
	
	int attributes = 0;
	
	attributes += attributeListCounter(img->rectangles, 1);
	attributes += attributeListCounter(img->circles, 2);
	attributes += attributeListCounter(img->paths, 3);
	attributes += getLength(img->otherAttributes);
	
	// get the attributes from groups
	ListIterator itr = createIterator(img->groups);
		
	Group* data = nextElement(&itr);
	while (data != NULL)
	{
		// 
		attributes += goThroughGroupAndAddAttributes(data);
		
		data = nextElement(&itr);
		
	}
		
	return attributes;
}


void deleteAttribute( void* data) {
	if(!data) {
		return;
	}
	
	Attribute* a = (Attribute*) data;
	
	// free name and value
	free(a->name);
	free(a->value);
	
	// free the struct itself
	free(a);

	return;
}
char* attributeToString( void* data) {
	if(!data) {
		return NULL;
	}
	
	return "attributeToString";
}
int compareAttributes(const void *first, const void *second) {
	// check for NULL
	if(!(first&&second)) {
		return 0;
	}
	
	
	return 0;
}


void deleteGroup(void* data) {
	if(!data) {
		return;
	}
	
	Group* g = (Group*) data;
	
	// clear the lists
	freeList(g->rectangles);
	freeList(g->circles);
	freeList(g->paths);
	freeList(g->groups);
	
	// free the other attributes list
	freeList(g->otherAttributes);
	
	free(g);
	
	return;
}
char* groupToString( void* data){
	if(!data) {
		return NULL;
	}
	
//	Group* group = (Group*) data;
	
/*	printf("group length = %d\n", getGroupLength(group));
	printf("\tnum rectans = %d\n", getLength(group->rectangles));
	printf("\tnum circles = %d\n", getLength(group->circles));
	printf("\tnum paths   = %d\n", getLength(group->paths));
	printf("\tnum groups  = %d\n", getLength(group->groups));*/
	
	char* string = malloc(sizeof(char) * 5);
	string[0] = 'G';
	string[1] = '\0';
	
	return string;
}
int compareGroups(const void *first, const void *second) {
	// check for NULL
	if(!(first&&second)) {
		return 0;
	}
	
	// TODO - will break code if used to sort groups hahahaha
	
	
	return 0;
}


void deleteRectangle(void* data) {
	// check for NULL
	if(!data) {
		return;
	}
	
	Rectangle* rect = (Rectangle*) data;
	
	// free miscellaneous attributes  
	freeList(rect->otherAttributes);

	// free the struct itself
	free(rect);
	
	return;
}
char* rectangleToString(void* data) {
	// check for NULL
	if(!data) {
		return NULL;
	}
	
	
	char* string = malloc(sizeof(char) * 5);
	string[0] = 'R';
	string[1] = '\0';
	
	return string;
}
int compareRectangles(const void *first, const void *second) {
	// check for NULL
	if(!(first&&second)) {
		return 0;
	}
	
	
	Rectangle* rect1 = (Rectangle*) first;
	Rectangle* rect2 = (Rectangle*) second;
	
	// calculate the areas
	float area1 = rect1->width * rect1->height;
	float area2 = rect2->width * rect2->height;
	
	// return 1 is the areas are equal
	if(ceil(area1) == ceil(area2)) {
		return 1;
	}
	
	return 0;
}


void deleteCircle(void* data) {
	// check for NULL
	if(!data) {
		return;
	}
	
	Circle* circle = (Circle*) data;
	
	// free miscellaneous attributes  
	freeList(circle->otherAttributes);

	// free the struct itself
	free(circle);
	
	return;
}
char* circleToString(void* data) {
	// check for NULL
	if(!data) {
		return NULL;
	}
	
//	Circle* c = (Circle*) data;
	
/*	printf("~~~ CIRCLE - %p ~~~\n", c);
	printf("\tcx = %lf\n\tcy = %lf\n\tr = %lf\n", c->cx, c->cy, c->r);
	printf("\tunits = %s\n", c->units);*/
	
	char* string = malloc(sizeof(char) * 5);
	string[0] = 'C';
	string[1] = '\0';
	
	return string;
}
int compareCircles(const void *first, const void *second) {
	// check for NULL
	if(!(first&&second)) {
		return 0;
	}
	
	
	Circle* circle1 = (Circle*) first;
	Circle* circle2 = (Circle*) second;
	
	// return 1 is the areas are equal (only need radius to compare area)
	if(ceil(circle1->r * circle1->r * PI ) == ceil(circle2->r * circle2->r * PI)) {
		return 1;
	}
	
	return 0;
}

void deletePath(void* data) {
	// check for NULL
	if(!data) {
		return;
	}
	
	Path* path = (Path*) data;
	
	// free data 
	free(path->data);
	
	// free miscellaneous attributes  
	freeList(path->otherAttributes);

	// free the struct itself
	free(path);
	
	return;
}

char* pathToString(void* data) {
	// check for NULL
	if(!data) {
		return NULL;
	}
	
	char* string = malloc(sizeof(char) * 5);
	string[0] = 'P';
	string[1] = '\0';
	
	return string;
}
int comparePaths(const void *first, const void *second) {
	// check for NULL
	if(!(first&&second)) {
		return 0;
	}
	
	
	Path* path1 = (Path*) first;
	Path* path2 = (Path*) second;
	
	// return string comparison
	return !strcmp(path1->data, path2->data);
}

